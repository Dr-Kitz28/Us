// Datasource
datasource db {
	## Switched to PostgreSQL for production deployments.
	## Set `DATABASE_URL` to a Postgres connection string in your environment.
	## Example: postgres://USER:PASSWORD@HOST:PORT/DATABASE
	provider = "postgresql"
	url      = env("DATABASE_URL")
}

// Generator
generator client {
	provider = "prisma-client-js"
}

model User {
	id        String   @id @default(cuid())
	email     String   @unique
	password  String
	name      String?
	image     String?  // User's profile image
	createdAt DateTime @default(now())
	updatedAt DateTime @updatedAt
	deletedAt DateTime?

	profile   Profile?
	photos    Photo[]
	likesGiven Like[]   @relation("likes_given")
	likesReceived Like[] @relation("likes_received")
	passesGiven Pass[]   @relation("passes_given")
	passesReceived Pass[] @relation("passes_received")
	matches1  Match[]   @relation("user1_matches")
	matches2  Match[]   @relation("user2_matches")
	messages  Message[]
	blocksInitiated Block[] @relation("blocks_initiated")
	blocksReceived  Block[] @relation("blocks_received")
	reportsFiled    Report[] @relation("reports_filed")
	reportsAgainst  Report[] @relation("reports_against")
	strikes         Strike[] @relation("user_strikes")
	safetyFlags     SafetyFlag[] @relation("user_safety_flags")
}

model Profile {
  id        String   @id @default(cuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id])
  bio       String?
  interests String?  // Changed from String[] to String - store as JSON or comma-separated
  gender    String?
  location  String?
  age       Int?
  
  // Golden Ratio Analysis Fields
  goldenRatioScore     Float?    // Ï† score (0-1.618)
  photoAnalyzed        Boolean   @default(false)
  photoAnalysisDate    DateTime?
  facialProportions    String?   // JSON string containing analysis data
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?
}model Photo {
	id        String   @id @default(cuid())
	userId    String
	user      User     @relation(fields: [userId], references: [id])
	url       String
	createdAt DateTime @default(now())
	deletedAt DateTime?
}

model Like {
	id        String   @id @default(cuid())
	fromId    String
	toId      String
	from      User     @relation("likes_given", fields: [fromId], references: [id])
	to        User     @relation("likes_received", fields: [toId], references: [id])
	createdAt DateTime @default(now())
	@@unique([fromId, toId])
}

model Pass {
	id        String   @id @default(cuid())
	fromId    String
	toId      String
	from      User     @relation("passes_given", fields: [fromId], references: [id])
	to        User     @relation("passes_received", fields: [toId], references: [id])
	createdAt DateTime @default(now())
	@@unique([fromId, toId])
}

model Match {
  id        String   @id @default(cuid())
  user1Id   String
  user2Id   String
  user1     User     @relation("user1_matches", fields: [user1Id], references: [id])
  user2     User     @relation("user2_matches", fields: [user2Id], references: [id])
  messages  Message[] // Add the missing opposite relation
  createdAt DateTime @default(now())
  deletedAt DateTime?
  @@unique([user1Id, user2Id])
}model Message {
	id          String   @id @default(cuid())
	matchId     String
	match       Match    @relation(fields: [matchId], references: [id])
	senderId    String
	sender      User     @relation(fields: [senderId], references: [id])
	content     String
	deliveredAt DateTime?
	seenAt      DateTime?
	createdAt   DateTime @default(now())
}

model Block {
	id        String   @id @default(cuid())
	blockerId String
	blockedId String
	blocker   User     @relation("blocks_initiated", fields: [blockerId], references: [id])
	blocked   User     @relation("blocks_received", fields: [blockedId], references: [id])
	reason    String?
	createdAt DateTime @default(now())
	@@unique([blockerId, blockedId])
}

model Report {
	id         String   @id @default(cuid())
	reporterId String
	reportedId String
	reporter   User     @relation("reports_filed", fields: [reporterId], references: [id])
	reported   User     @relation("reports_against", fields: [reportedId], references: [id])
	category   String   // harassment, fake_profile, inappropriate_content, scam, spam, underage, violence, hate_speech, other
	reason     String
	description String?
	evidence   String?  // JSON array of evidence URLs
	priority   String   @default("medium") // critical, high, medium, low
	status     String   @default("pending") // pending, reviewing, resolved, dismissed
	reviewerId String?
	reviewerNotes String?
	resolvedAt DateTime?
	createdAt  DateTime @default(now())
	updatedAt  DateTime @updatedAt
}

model Strike {
	id        String   @id @default(cuid())
	userId    String
	user      User     @relation("user_strikes", fields: [userId], references: [id])
	reportId  String?
	reason    String
	severity  String   // warning, restrict, suspend, ban
	expiresAt DateTime?
	createdAt DateTime @default(now())
	updatedAt DateTime @updatedAt
}

model SafetyFlag {
	id        String   @id @default(cuid())
	userId    String
	user      User     @relation("user_safety_flags", fields: [userId], references: [id])
	flagType  String   // auto_moderated, manual_review, high_risk, verified_safe
	reason    String?
	isActive  Boolean  @default(true)
	createdAt DateTime @default(now())
	updatedAt DateTime @updatedAt
}

